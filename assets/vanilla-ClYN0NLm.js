import{h as B,F as w,j as D,k,m as J}from"./index-CGjvahgo.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const F=w(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),P=F.create(BigInt("-3")),A=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),R=B({a:P,b:A,Fp:F,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},D),C=w(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff")),U=C.create(BigInt("-3")),G=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef");B({a:U,b:G,Fp:C,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},k);const j=w(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),H=j.create(BigInt("-3")),M=BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00");B({a:H,b:M,Fp:j,n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),h:BigInt(1),lowS:!1,allowedPrivateKeyLengths:[130,131,132]},J);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const X=R,Q=R,E={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},O=new Map,y=d=>{const c=O.get(d);return c?Object.fromEntries(Object.entries(c.stores).map(([f,n])=>[f,n.getState()])):{}},L=(d,c,f)=>{if(d===void 0)return{type:"untracked",connection:c.connect(f)};const n=O.get(f.name);if(n)return{type:"tracked",store:d,...n};const e={connection:c.connect(f),stores:{}};return O.set(f.name,e),{type:"tracked",store:d,...e}},W=(d,c={})=>(f,n,e)=>{const{enabled:a,anonymousActionType:m,store:r,...b}=c;let l;try{l=(a??(E?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!l)return d(f,n,e);const{connection:o,...v}=L(r,l,b);let g=!0;e.setState=(t,S,s)=>{const i=f(t,S);if(!g)return i;const p=s===void 0?{type:m||"anonymous"}:typeof s=="string"?{type:s}:s;return r===void 0?(o?.send(p,n()),i):(o?.send({...p,type:`${r}/${p.type}`},{...y(b.name),[r]:e.getState()}),i)};const u=(...t)=>{const S=g;g=!1,f(...t),g=S},h=d(e.setState,n,e);if(v.type==="untracked"?o?.init(h):(v.stores[v.store]=e,o?.init(Object.fromEntries(Object.entries(v.stores).map(([t,S])=>[t,t===v.store?h:S.getState()])))),e.dispatchFromDevtools&&typeof e.dispatch=="function"){let t=!1;const S=e.dispatch;e.dispatch=(...s)=>{(E?"production":void 0)!=="production"&&s[0].type==="__setState"&&!t&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),t=!0),S(...s)}}return o.subscribe(t=>{var S;switch(t.type){case"ACTION":if(typeof t.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return _(t.payload,s=>{if(s.type==="__setState"){if(r===void 0){u(s.state);return}Object.keys(s.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const i=s.state[r];if(i==null)return;JSON.stringify(e.getState())!==JSON.stringify(i)&&u(i);return}e.dispatchFromDevtools&&typeof e.dispatch=="function"&&e.dispatch(s)});case"DISPATCH":switch(t.payload.type){case"RESET":return u(h),r===void 0?o?.init(e.getState()):o?.init(y(b.name));case"COMMIT":if(r===void 0){o?.init(e.getState());return}return o?.init(y(b.name));case"ROLLBACK":return _(t.state,s=>{if(r===void 0){u(s),o?.init(e.getState());return}u(s[r]),o?.init(y(b.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return _(t.state,s=>{if(r===void 0){u(s);return}JSON.stringify(e.getState())!==JSON.stringify(s[r])&&u(s[r])});case"IMPORT_STATE":{const{nextLiftedState:s}=t.payload,i=(S=s.computedStates.slice(-1)[0])==null?void 0:S.state;if(!i)return;u(r===void 0?i:i[r]),o?.send(null,s);return}case"PAUSE_RECORDING":return g=!g}return}}),h},Y=W,_=(d,c)=>{let f;try{f=JSON.parse(d)}catch(n){console.error("[zustand devtools middleware] Could not parse the received json",n)}f!==void 0&&c(f)},$=d=>(c,f,n)=>{const e=n.subscribe;return n.subscribe=(m,r,b)=>{let l=m;if(r){const o=b?.equalityFn||Object.is;let v=m(n.getState());l=g=>{const u=m(g);if(!o(v,u)){const h=v;r(v=u,h)}},b?.fireImmediately&&r(v,v)}return e(l)},d(c,f,n)},Z=$;function q(d,c){let f;try{f=d()}catch{return}return{getItem:e=>{var a;const m=b=>b===null?null:JSON.parse(b,void 0),r=(a=f.getItem(e))!=null?a:null;return r instanceof Promise?r.then(m):m(r)},setItem:(e,a)=>f.setItem(e,JSON.stringify(a,void 0)),removeItem:e=>f.removeItem(e)}}const x=d=>c=>{try{const f=d(c);return f instanceof Promise?f:{then(n){return x(n)(f)},catch(n){return this}}}catch(f){return{then(n){return this},catch(n){return x(n)(f)}}}},z=(d,c)=>(f,n,e)=>{let a={storage:q(()=>localStorage),partialize:t=>t,version:0,merge:(t,S)=>({...S,...t}),...c},m=!1;const r=new Set,b=new Set;let l=a.storage;if(!l)return d((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`),f(...t)},n,e);const o=()=>{const t=a.partialize({...n()});return l.setItem(a.name,{state:t,version:a.version})},v=e.setState;e.setState=(t,S)=>{v(t,S),o()};const g=d((...t)=>{f(...t),o()},n,e);e.getInitialState=()=>g;let u;const h=()=>{var t,S;if(!l)return;m=!1,r.forEach(i=>{var p;return i((p=n())!=null?p:g)});const s=((S=a.onRehydrateStorage)==null?void 0:S.call(a,(t=n())!=null?t:g))||void 0;return x(l.getItem.bind(l))(a.name).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==a.version){if(a.migrate){const p=a.migrate(i.state,i.version);return p instanceof Promise?p.then(I=>[!0,I]):[!0,p]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,i.state];return[!1,void 0]}).then(i=>{var p;const[I,N]=i;if(u=a.merge(N,(p=n())!=null?p:g),f(u,!0),I)return o()}).then(()=>{s?.(u,void 0),u=n(),m=!0,b.forEach(i=>i(u))}).catch(i=>{s?.(void 0,i)})};return e.persist={setOptions:t=>{a={...a,...t},t.storage&&(l=t.storage)},clearStorage:()=>{l?.removeItem(a.name)},getOptions:()=>a,rehydrate:()=>h(),hasHydrated:()=>m,onHydrate:t=>(r.add(t),()=>{r.delete(t)}),onFinishHydration:t=>(b.add(t),()=>{b.delete(t)})},a.skipHydration||h(),u||g},V=z,T=d=>{let c;const f=new Set,n=(l,o)=>{const v=typeof l=="function"?l(c):l;if(!Object.is(v,c)){const g=c;c=o??(typeof v!="object"||v===null)?v:Object.assign({},c,v),f.forEach(u=>u(c,g))}},e=()=>c,r={setState:n,getState:e,getInitialState:()=>b,subscribe:l=>(f.add(l),()=>f.delete(l))},b=c=d(n,e,r);return r},tt=d=>d?T(d):T;export{Z as a,V as b,tt as c,Y as d,q as e,X as p,Q as s};
